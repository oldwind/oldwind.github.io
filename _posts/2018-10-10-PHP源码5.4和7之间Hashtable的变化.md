---
layout: content
title: php源码5.4和7之间hashtable的变化
category: c and c++
---

## 一.背景
最近在写php的扩展，需要适配php的各个版本，顺道总结比较一下php版本的差异，为什么比较5.4和7.0呢，而不是较新的5.6和7.0呢？主要是因为公司内大部分产品线目前都使用的是php的5.4版本，还没有使用5.6版本，php7.0在性能上得到了很大的飞跃，按照网上的说法，php7.0在性能上比5.6都提升了两倍，核心原因，说法主要是hashtable的设计做了很大的修改，所以文章目前主要是就5.4的hashtable设计和7.0的hashtable设计做做分析，谈谈我的认识。


## 二.php5.4的hashtable设计

### 2.1 hashtable的总体结构
读5.4的hashtable设计，感觉非常的清晰，设计的也很巧妙，我们用一张图来看一下

![hashtable图片](/images/php/php5.4hashtable.jpg)

我们先省略掉某些字段细节，着重看一下结构，从图中看，底层的hashtable采用了"开链法"解决hash冲突，总体上分层三部分看

1. 第一部分 hashtable维护了一个二级指针(Bucket **)，这个二级指针指向一段申请的连续内存，当有KEY VALUE存到hashtable时候，KEY值被经过hash计算，会通过指针偏移的方式，迅速找到存储的头地址，可以看头地址指向的"桶"(Bucket)是否为空，如果不为空，则新申请一个"桶"按照双向链表的设计放在最后

2. 第二部分，冲突的"桶"通过双向链表串联外，实际上，还维护了一个"顺序"双向链表，HashTable结构维护了顺序链表的起始位置和结束位置，这个双向链表的作用非常大，实际上，实现了"栈"和"队列"的功能，例如基于HashTable设计的php数组结构，在实现 array_push(), array_pop(), array_shift(), 会变成对一双向链表做简单操作

3. 第三部分，顺序的双向链表在循环时候，变得会非常简单


### 2.2 hashtable的数据结构详解

#### 2.2.1 HashTable
{% highlight C %} typedef struct _hashtable {
	uint nTableSize;     /* hashtable 的容量，实际上就是 Bucket ** 指针指向的内存大小 / 8 (64位，指针一般占8个字节) */
	uint nTableMask;            /* 大小值一般是容量 -1,  */    
	uint nNumOfElements;        /* hashtable中的元素个数 */
	ulong nNextFreeElement;
	Bucket *pInternalPointer;	/* Used for element traversal */
	Bucket *pListHead;          /* 顺序双向链表的头指针 */
	Bucket *pListTail;          /* 顺序双向链表的尾指针 */
	Bucket **arBuckets;         /* 指向"桶"指针"数组"的指针*/
	dtor_func_t pDestructor;   /* 析构函数 */
	zend_bool persistent;
	unsigned char nApplyCount;
	zend_bool bApplyProtection;
#if ZEND_DEBUG
	int inconsistent;
#endif
} HashTable;
{% endhighlight %}

结构体的主要成员变量，在上面的代码中加了注释， `nNumOfElements` 是一个非常实用的字段，在数组中，经常会用到 `count($arr)`， 如果没有这个字段，count的耗时将是O(N), 在根据KEY 找桶的过程中，还有一个细节可以关注，通过hash算法计算出来的hash值在与 nTableMask 做运算的时候，选择的是 `&` 操作，不是 `%` 操作，这也是从细节上提升了点滴性能

#### 2.2.2 Bucket
{% highlight C %} typedef struct bucket {
	ulong h;			       /* Used for numeric indexing */
	uint nKeyLength;
	void *pData;                /* value指针 */          
	void *pDataPtr;
	struct bucket *pListNext;   /* 顺序双向链表下一个元素的指针 */
	struct bucket *pListLast;   /* 顺序双向链表上一个元素的指针 */
	struct bucket *pNext;       /* 冲撞双向链表下一个元素的指针 */
	struct bucket *pLast;       /* 冲撞双向链表上一个元素的指针 */
	const char *arKey;          /* KEY指针 */
} Bucket;
{% endhighlight %}

`Bucket`是存放Key value的桶，可以看出，key和value都是指针，也就是实际上，Key Value都不存在Bucket里面，这里在使用中，php对于Key是数字的情况，会用另外一种处理方式，增加了一个字段 `ulong h` ,KEY和`h`字段保持一样，有两个好处
1. 不需要寻址一次，去查key的值
2. 不需要使用hash算法，经过复杂的hash计算，得到hash值，直接采用`h & nTableMask` 则找到填充的桶的头指针位置，但是这里面似乎有一个风险，`如果所有的 h & nTableMask 都等于一个值，那么是否存在hash攻击风险，使得 hashtable的性能达到最低 ？` 例如，`nTableMask = 2 ^ 32 -1`，那么则存在 `2 ^ 32` 个数字在一条链上，由hashtable变成了双向链表, 当然这个后面看一下php的`array`的实现，看看是否存在这样的可能. 
合并`h`和Key的方案，在判断取`h`还是`arKey`还可以从 `nKeyLength`的长度来判断，如果`nKeyLength = 0`, 则明显是合并了，而如果 `nKeyLength != 0`, 则 `h`并不是KEY，是外部hash算法计算出来的hash值，Key是 `arKey` 指向的字符串 


#### 2.2.3 hashtable操作Api

第一个，我们看一下初始化
{% highlight C %} ZEND_API int _zend_hash_init(HashTable *ht, uint nSize, hash_func_t pHashFunction, dtor_func_t pDestructor, zend_bool persistent ZEND_FILE_LINE_DC)
{
	uint i = 3;

	SET_INCONSISTENT(HT_OK);

	if (nSize >= 0x80000000) {
		/* prevent overflow */
		ht->nTableSize = 0x80000000;
	} else {
		while ((1U << i) < nSize) {
			i++;
		}
		ht->nTableSize = 1 << i;
	}

	ht->nTableMask = 0;	/* 0 means that ht->arBuckets is uninitialized */
	...
}
{% endhighlight %}

初始化hashtable需要关注两个问题
1. 我们可以看到，hashtable的内存管理由使用方决定，可以在堆上，也可以在栈上，调用者决定
2. `nTableSize`的大小是2的倍数，当然不可以过大

**初始化完毕后，对hashtable进行写操作或者更新操作，如果KEY存在，则更新，如果不存在则增加。而hashtable在设计中，在我看来,还考虑了以下几个问题**
1. 前面提到的KEY的类型，数字和字符串，处理方式不一样
2. 外面是否有自己的hash算法，如果有，则用外面的hash算法计算的KEY的hash值，没有，则用内部的hash值
3. `数据的更新，是否需要阻塞进程?`
4. Bucket存放数据，那么内存的申请由谁来负责！
5. `如果存放的成员数据过多，怎么办？`

**下面，我们来解答这些问题**

1\. 1和2在前面已经提到，`ulong h`字段非常灵活，可以是外面定义的hash算法计算出来的hash值，也可以是Key是数字的Key值，可以灵活使用。其中下面的内置Api `_zend_hash_quick_add_or_update` 支持这两种用法

2\. 下面是hashtable提供的内置函数定义，对外接口，通过宏定义，可以有更好函数命名，不同的接口，定义不同，
- `_zend_hash_quick_add_or_update` 处理KEY是字符串或者数字两种情况
- `_zend_hash_add_or_update` 不接受外部hash算法，会调用内部hash算法来计算hash值，并且保存


{% highlight c %}ZEND_API int _zend_hash_add_or_update(HashTable *ht, const char *arKey, uint nKeyLength, void *pData, uint nDataSize, void **pDest, int flag ZEND_FILE_LINE_DC);

ZEND_API int _zend_hash_quick_add_or_update(HashTable *ht, const char *arKey, uint nKeyLength, ulong h, void *pData, uint nDataSize, void **pDest, int flag ZEND_FILE_LINE_DC);

ZEND_API int _zend_hash_index_update_or_next_insert(HashTable *ht, ulong h, void *pData, uint nDataSize, void **pDest, int flag ZEND_FILE_LINE_DC);

ZEND_API int zend_hash_add_empty_element(HashTable *ht, const char *arKey, uint nKeyLength);
{% endhighlight %}

3\. 数据在发生更新和写入操作的时候，是会进行阻塞处理的，为此，php提供了两个宏，来处理，具体的实现，这里不在详细描述
{% highlight c %}HANDLE_BLOCK_INTERRUPTIONS();
...
HANDLE_UNBLOCK_INTERRUPTIONS();
{% endhighlight %}

4\. hashtable中Bucket以及KEY，value等，都是在堆里面申请，其中 bucket和key的存储在一起，可以通过指针偏移拿到key值
{% highlight c %} p = (Bucket *) pemalloc(sizeof(Bucket) + nKeyLength, ht->persistent);
if (!p) {
	return FAILURE;
}
p->arKey = (const char*)(p + 1);
memcpy((char*)p->arKey, arKey, nKeyLength);
{% endhighlight %}

5\. 非常重要的rehash，hash的KEY太多，如果tablesize小，则容易退化成双向链表，性能受到很大影响，
5.1. 什么时候启动rehash 如果已有KEY的数量比nTablesize还多的时候
{% highlight c %} #define ZEND_HASH_IF_FULL_DO_RESIZE(ht)		\
if ((ht)->nNumOfElements > (ht)->nTableSize) {	\
	zend_hash_do_resize(ht);					\
}
{% endhighlight %}

5.2\. 具体步骤是怎么样的呢
- 第一步，申请2倍 ntablesize大小的空间，存放`Bucket`指针"数组"
- 第二步，阻塞进程
- 第三步，拿到原来hashtable 顺序链表的头指针p，通过p->pListNext启动循环
	- 为 p->ListNext 申请内存
	- 找到p->ListNext 经过hash算法应该在的bucket
	- 判断bucket指向是否有冲撞，
		- 冲撞则遍历"冲撞双向链表",记在双向链表最后，同时构成双向链表
		- 没有冲撞，则记在bucket指向的地址
- 第四步，打开阻塞的进程

hashtable还有非常多的操作，都比有意思，例如像 `copy`, `merge`， `find`，`compare`， `sort` 等等，这里不在一一说明。


### 2.3 php数组和hashtable的关系

HashTable是内核提供给外部的核心数据结构，在ext的标准库里面，设计的数组，主要使用到了HashTable，我们看一下array和Hashtable的关系






## 三.php7.0的hashtable设计
## 四.总结比较
## 五.后记