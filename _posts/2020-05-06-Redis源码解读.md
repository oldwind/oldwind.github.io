---
layout: content
title: redis源码解读
status: 1
category: redis, c
author:   "yimuren"
tags:
    - c
---

## 一. 前言

### 1.1 redis简介

**百度百科**

> Redis（Remote Dictionary Server)，即远程字典服务，是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。从2010年3月15日起，Redis的开发工作由VMware主持。从2013年5月开始，Redis的开发由Pivotal赞助。 


**维基百科**


```bash
开发者  Salvatore Sanfilippo 
初始版本	2009年5月10日，​10年前
稳定版本	6.0.1（2020年5月1日，​4天前 [1]）
预览版本	6.0 RC4（2020年4月16日，​19天前 [2]）
源代码库	github.com/antirez/redis
编程语言	ANSI C
操作系统	跨平台
语言	英语
类型	非关系型数据库
许可协议	BSD
网站	redis.io
```

### 1.2 redis的应用

作为key-value数据库，redis的"value"，支持多种数据结构，有 string，list，hash, set, zset, bitmaps, hyperloglogs, geospatial indexe .丰富的数据结构，高效率的内存查询，以及支持灵活的lua脚本和事物 支持redis在越来越多的场景下得到广泛应用

在这里简单的举一些使用的例子

#### 1.2.1 分布式锁

锁的出现是解决某些资源不允许并发访问的需求，例如数据库的行数据(行级锁)、表数据(表级锁)，锁的实现方式有多种方式，有数据库锁、redis锁、单机情况下可以采用文件锁，实现redis分布式锁的方式有两种

##### 1.2.1.1 setnx实现分布式锁

setnx 是 set if not exsit， 如果不存在则set，用在锁上，可以多个进程尝试去 setnx, 那么则只有一个尝试成功，用伪代码表示一下加锁的过程

```bash
    set ok =  setnx(key, value); 
    if ok {
        doSomething();  
        del(key);  // 删除锁
    } else {
        ...
    }
```

但是很明显，如果doSomething()过程中，进程断了 或者 del() 过程中失败，将会导致锁无法释放，这个过程中，将增加失效时间来解决锁的异常释放问题

```bash
    set ok =  setnx(key, value); 
    if ok {
        expire(key, second); // 增加失效时间
        doSomething();  
        del(key);  // 删除锁
    } else {
        ...
    }
```

增加失效时间后，发现setnx 和 expire 突然不是原子操作了，那么同样存在，setnx成功后，进程断了，锁将永远不会被释放的情况, 为了解决这个原子性的问题，有很多方案被考虑， redis支持lua操作，可以用lua脚本来实现原子性， 或者 用redis的事物，但是redis的事物后面会分析一下源码，实际上redis的事物只是在server端设计了一个队列，将redis指令的操作放到队列里面，一次性在server端执行了，所以没有mvcc，没有事物的回滚机制，并没有解决redis锁设定的原子性问题

这个时候，可以看看set 命令来实现锁

##### 1.2.1.2 set 指令对锁的实现

`set key value [EX seconds] [PX milliseconds] [NX|XX]`

从 Redis 2.6.12 版本开始, redis的set指令实际上把 setnx，setex, psetex 指令功能做了合并

- EX 表示秒级别失效
- PX 表示毫米级别失效
- NX 表示不存在则操作
- XX 表示存在则操作 

关于锁失效的时间和doSomething()的事件设计问题，这里不再细谈，那么redis的set命令实现了锁操作的原子性(?)， 后面通过源码我们分析一下

#### 1.2.2 排行榜

做排行榜的方式有很多，基于数据库的，基于redis的，基于日志分析的流式计算的, 如果排行榜要求在高并发情况下时延最低，那么redis肯定是"不二人选"，redis做排行榜基于的是它 value的 zset数据结构，也就是 排序集合，首先集合解决了重复key问题，排序方式可以在内存中快速获取top数据

```bash
127.0.0.1:6379> zadd rank-guess 40 tom
(integer) 1
127.0.0.1:6379> zadd rank-guess 30 Ben
(integer) 1
127.0.0.1:6379> zadd rank-guess 30 jordon
(integer) 1
127.0.0.1:6379> zadd rank-guess 10 john
(integer) 1
127.0.0.1:6379>
127.0.0.1:6379> zrange rank-guess 0 1
1) "john"
2) "Ben"
127.0.0.1:6379> zrange rank-guess 0 1 withscores
1) "john"
2) "10"
3) "Ben"
4) "30"
127.0.0.1:6379> zrevrange rank-guess 0 1 withscores
1) "tom"
2) "40"
3) "jordon"
4) "30"
```

redis 做排行榜非常简单，zadd创建一个榜单，zrange可以正序获取榜单数据，zrevrange 从后截取榜单数据

- zadd  `zadd key [NX|XX] [CH] [INCR] score member [score member ...]`
- zrange  `zrange key start stop [WITHSCORES]`
- zrevrange `zrevrange key start stop [WITHSCORES]`

我们从redis的zadd命令中可以看出，zadd还支持对榜单的元素做自增操作，非常方便

```bash
127.0.0.1:6379> zadd rank-guess incr 1 jordon
"31"
127.0.0.1:6379> zrevrange rank-guess 0 1 withscores
1) "tom"
2) "40"
3) "jordon"
4) "31"
```

#### 1.2.3 简单队列

redis提供了做队列的功能，


#### 1.2.4 计数器


#### 1.2.5 分布式会话






### 1.3 缓存比较


## 二. redis的源码初探

在前面看了redis的一些常见使用场景，在这节主要的目的是对redis源码做一些分析，分析redis源码按照下面的主要流程进行

1. 源码下载 https://github.com/antirez/redis
2. 编译debug版本 可以阅读一下redis的makefile，执行make
3. 边看边执行代码，

### 2.1 源码结构

查看一下redis的目录树

- `src` 目录是redis的核心代码目录
- `deps` 目录是redis依赖的第三方功能，例如lua脚本支持，内存管理等等
- `tests` 单元测试目录
- `redis.conf` redis的配置文件
- `sentinel.conf` redis的哨兵配置文件
- `utils` redis的工具实现

```bash
-rw-rw-r--   1 work work 93478 Mar 31 18:02 00-RELEASENOTES
-rw-r--r--   1 work work    53 Mar 30 18:06 BUGS
-rw-rw-r--   1 work work  1805 Mar 31 18:02 CONTRIBUTING
-rw-r--r--   1 work work  1487 Mar 30 18:06 COPYING
-rw-r--r--   1 work work    11 Mar 30 18:06 INSTALL
-rw-rw-r--   1 work work  4223 Mar 31 13:56 MANIFESTO
-rw-r--r--   1 work work   151 Mar 30 18:06 Makefile
-rw-rw-r--   1 work work  6834 Mar 31 18:02 README.md
drwxr-xr-x  13 work work   416 Mar 31 18:02 deps
-rw-rw-r--   1 work work 46695 Mar 31 18:02 redis.conf
-rw-rw-r--   1 work work  7971 Apr  8 10:57 sentinel.conf
drwxr-xr-x 178 work work  5696 Mar 31 18:04 src
drwxr-xr-x  12 work work   384 Mar 31 18:02 tests
drwxr-xr-x  18 work work   576 Mar 31 18:02 utils
```

redis里面的deps文件夹，进去看一下，make的时候


```bash
|-- deps
|   |-- Makefile
|   |-- README.md
|   |-- geohash-int
|   |-- hiredis
|   |-- jemalloc
|   |-- linenoise
|   |-- lua
|   `-- update-jemalloc.sh
```

### 2.2 redis的服务介绍

## 三. redis的数据结构和算法

> Pascal之父——Nicklaus  "算法+数据结构=程序"

分析redis的源码，需要从redis基础的数据结构和算法开始，


- 网络
- 存储
    - sds
    - ziplist
    - 
- 集群管理
- 通用工具

### 3.1 ae

**`ae`**： 作者的定义是 "A simple event-driven programming library "， 一个简单的事件驱动库.

redis 的作者把事件定义为两种：

- 一种是 aeFileEvent 称之为 文件事件，实际上，主要是处理socket fd 的事件
- 另外一种是 aeTimeEvent 可以称之为 时间事件

另外redis还设计了一个数据结构 aeFiredEvent 存储被激活的事件




### 3.2 adlist

**`adlist`** : “ A generic doubly linked list implementation ”, adlist 是 redis作者实现的一个双向链表, 这个双向链表非常简单，包含两部分元素

1. `list` 管理双向链表"节点"
2. `listNode` 双向链表的节点，每个节点有两个指针，指向前后元素，头节点的前元素是`null`, 


```c
typedef struct listNode {
    struct listNode *prev;
    struct listNode *next;
    void *value;
} listNode;

typedef struct list {
    listNode *head;
    listNode *tail;
    void *(*dup)(void *ptr);
    void (*free)(void *ptr);
    int (*match)(void *ptr, void *key);
    unsigned long len;
} list;

```

![]({{site.baseurl}}/img/tech/2020-05-07-16-52-43.png)


adlist的双向链表设计在多处使用到, 例如，server启动后，连接的 client， 实际上，这个数据结构并不是用在redis的value对list的支持上

### 3.3 quicklist




### 3.4 dict

dict是redis对hashtable的具体实现，hash冲撞采用比较传统的“开链法”，但是在基础上做了升级，我想作者重点考虑了下面几个问题

1. 如何解决，hash表元素达到一定规模，冲撞过程中的元素形成的链表越来越长，影响性能的问题？
2. k-v结构中value类型是整形和字符串的区别, 如何提升性能问题？

解决冲突导致的"开链"，链表的长度越长，在find查找过程中，即便查到元素所在的bucket，也需要遍历链表查找元素是存在，这里面对性能影响有两个方面

1. 遍历过程中需要多次比较元素，
2. 遍历链表中查找下一个元素的寻址问题。

![]({{site.baseurl}}/img/tech/2020-05-07-17-43-10.png)

如何提高性能呢？

我想redis的作者在考虑这个问题的时候，给出了他的方案

#### 3.4.1 rehash

rehash是一种扩容方案，假设我们的hash表bucket的数量是4，如果只有4个元素，经过hash计算，较为平均的分配在各个bucket中，性能比较棒，而如今，元素的个数增长到40个，很显然hash冲突比较多，性能降低，在这个时候redis考虑增加bucket的数量，缓步将原来bucket的元素迁移到现在的bucket中，这个就是redis作者设计的rehash

那么什么时候需要rehash呢？如何触发rehash呢？以及如何进行rehash呢？

**第一个问题： 什么时候启动rehash**





![]({{site.baseurl}}/img/tech/2020-05-07-19-52-35.png)

### 3.5 sds

### 3.6 ziplist

### 3.7 cluster

### 3.8 client

### 3.9 server



## 四. redis-server的启动流程

## 五. redis的内存管理机制


## 五. lua脚本在redis中的使用和实现

## 八. redis的持久化

## 九. redis的部署篇


## 十.参考文献
1. 百度百科redis介绍 https://baike.baidu.com/item/Redis/6549233?fr=aladdin
2. 维基百科redis介绍 https://zh.wikipedia.org/wiki/Redis
3. redis命令参考 http://redisdoc.com/ 