---
layout: content
title: php内核5.4和7之间HashTable的变化
category: c and c++
---

## 一.背景
最近在写php的扩展，需要适配php的各个版本，顺道总结比较一下php版本的差异，为什么比较5.4和7.0呢，而不是较新的5.6和7.0呢？主要是因为公司内大部分产品线目前都使用的是php的5.4版本，还没有使用5.6版本，php7.0在性能上得到了很大的飞跃，按照网上的说法，php7.0在性能上比5.6都提升了两倍，核心原因，说法主要是HashTable的设计做了很大的修改，所以文章目前主要是就5.4的HashTable设计和7.0的HashTable设计做做分析，谈谈我的认识。


## 二.php5.4的HashTable设计

### 2.1 HashTable的总体结构
读5.4的HashTable设计，感觉非常的清晰，设计的也很巧妙，我们用一张图来看一下

![HashTable图片](/images/php/php5.4HashTable.jpg)

我们先省略掉某些字段细节，着重看一下结构，从图中看，底层的HashTable采用了"开链法"解决hash冲突，总体上分层三部分看

1. 第一部分 HashTable维护了一个二级指针(Bucket **)，这个二级指针指向一段申请的连续内存，当有KEY VALUE存到HashTable时候，KEY值被经过hash计算，会通过指针偏移的方式，迅速找到存储的头地址，可以看头地址指向的"桶"(Bucket)是否为空，如果不为空，则新申请一个"桶"按照双向链表的设计放在最后

2. 第二部分，冲突的"桶"通过双向链表串联外，实际上，还维护了一个"顺序"双向链表，HashTable结构维护了顺序链表的起始位置和结束位置，这个双向链表的作用非常大，实际上，实现了"栈"和"队列"的功能，例如基于HashTable设计的php数组结构，在实现 array_push(), array_pop(), array_shift(), 会变成对一双向链表做简单操作

3. 第三部分，顺序的双向链表在循环时候，变得会非常简单


### 2.2 HashTable的数据结构详解

#### 2.2.1 HashTable
{% highlight C %} typedef struct _HashTable {
	uint nTableSize;     /* HashTable 的容量，实际上就是 Bucket ** 指针指向的内存大小 / 8 (64位，指针一般占8个字节) */
	uint nTableMask;            /* 大小值一般是容量 -1,  */    
	uint nNumOfElements;        /* HashTable中的元素个数 */
	ulong nNextFreeElement;
	Bucket *pInternalPointer;	/* Used for element traversal */
	Bucket *pListHead;          /* 顺序双向链表的头指针 */
	Bucket *pListTail;          /* 顺序双向链表的尾指针 */
	Bucket **arBuckets;         /* 指向"桶"指针"数组"的指针*/
	dtor_func_t pDestructor;   /* 析构函数 */
	zend_bool persistent;
	unsigned char nApplyCount;
	zend_bool bApplyProtection;
#if ZEND_DEBUG
	int inconsistent;
#endif
} HashTable;
{% endhighlight %}

结构体的主要成员变量，在上面的代码中加了注释， `nNumOfElements` 是一个非常实用的字段，在数组中，经常会用到 `count($arr)`， 如果没有这个字段，count的耗时将是O(N), 在根据KEY 找桶的过程中，还有一个细节可以关注，通过hash算法计算出来的hash值在与 nTableMask 做运算的时候，选择的是 `&` 操作，不是 `%` 操作，这也是从细节上提升了点滴性能

#### 2.2.2 Bucket
{% highlight C %} typedef struct bucket {
	ulong h;			        /* Used for numeric indexing */
	uint nKeyLength;            /* KEY字符串长度 */
	void *pData;                /* value指针 */          
	void *pDataPtr;             /* 数据指针 */
	struct bucket *pListNext;   /* 顺序双向链表下一个元素的指针 */
	struct bucket *pListLast;   /* 顺序双向链表上一个元素的指针 */
	struct bucket *pNext;       /* 冲撞双向链表下一个元素的指针 */
	struct bucket *pLast;       /* 冲撞双向链表上一个元素的指针 */
	const char *arKey;          /* KEY指针 */
} Bucket;
{% endhighlight %}

`Bucket`是存放Key value的桶，可以看出，key和value都是指针，也就是实际上，Key Value都不存在Bucket里面，这里在使用中，php对于Key是数字的情况，会用另外一种处理方式，增加了一个字段 `ulong h` ,KEY和`h`字段保持一样，有两个好处
1. 不需要寻址一次，去查key的值
2. 不需要使用hash算法，经过复杂的hash计算，得到hash值，直接采用`h & nTableMask` 则找到填充的桶的头指针位置，但是这里面似乎有一个风险，`如果所有的 h & nTableMask 都等于一个值，那么是否存在hash攻击风险，使得 HashTable的性能达到最低 ？` 例如，`nTableMask = 2 ^ 32 -1`，那么则存在 `2 ^ 32` 个数字在一条链上，由HashTable变成了双向链表, 当然这个后面看一下php的`array`的实现，看看是否存在这样的可能. 
合并`h`和Key的方案，在判断取`h`还是`arKey`还可以从 `nKeyLength`的长度来判断，如果`nKeyLength = 0`, 则明显是合并了，而如果 `nKeyLength != 0`, 则 `h`并不是KEY，是外部hash算法计算出来的hash值，Key是 `arKey` 指向的字符串 

另外，需要关注一下，`pData` 和 `pDataPtr`两个指针，一个是数据指针，一个是指向数据的指针，也就是针对KEY Value结构，如果value是指针，则直接存在`pDataPtr`中，如果是数据，则存在`pData`指向的存储位置

#### 2.2.3 HashTable操作Api

第一个，我们看一下初始化
{% highlight C %} ZEND_API int _zend_hash_init(HashTable *ht, uint nSize, hash_func_t pHashFunction, dtor_func_t pDestructor, zend_bool persistent ZEND_FILE_LINE_DC)
{
	uint i = 3;

	SET_INCONSISTENT(HT_OK);

	if (nSize >= 0x80000000) {
		/* prevent overflow */
		ht->nTableSize = 0x80000000;
	} else {
		while ((1U << i) < nSize) {
			i++;
		}
		ht->nTableSize = 1 << i;
	}

	ht->nTableMask = 0;	/* 0 means that ht->arBuckets is uninitialized */
	...
}
{% endhighlight %}

初始化HashTable需要关注两个问题
1. 我们可以看到，HashTable的内存管理由使用方决定，可以在堆上，也可以在栈上，调用者决定
2. `nTableSize`的大小是2的倍数，当然不可以过大

**初始化完毕后，对HashTable进行写操作或者更新操作，如果KEY存在，则更新，如果不存在则增加。而HashTable在设计中，在我看来,还考虑了以下几个问题**
1. 前面提到的KEY的类型，数字和字符串，处理方式不一样
2. 外面是否有自己的hash算法，如果有，则用外面的hash算法计算的KEY的hash值，没有，则用内部的hash值
3. `数据的更新，是否需要阻塞进程?`
4. Bucket存放数据，那么内存的申请由谁来负责！
5. `如果存放的成员数据过多，怎么办？`

**下面，我们来解答这些问题**

1\. 1和2在前面已经提到，`ulong h`字段非常灵活，可以是外面定义的hash算法计算出来的hash值，也可以是Key是数字的Key值，可以灵活使用。其中下面的内置Api `_zend_hash_quick_add_or_update` 支持这两种用法
2\. 下面是HashTable提供的内置函数定义，对外接口，通过宏定义，可以有更好函数命名，不同的接口，定义不同，
- `_zend_hash_quick_add_or_update` 处理KEY是字符串或者数字两种情况
- `_zend_hash_add_or_update` 不接受外部hash算法，会调用内部hash算法来计算hash值，并且保存


{% highlight c %}ZEND_API int _zend_hash_add_or_update(HashTable *ht, const char *arKey, uint nKeyLength, void *pData, uint nDataSize, void **pDest, int flag ZEND_FILE_LINE_DC);

ZEND_API int _zend_hash_quick_add_or_update(HashTable *ht, const char *arKey, uint nKeyLength, ulong h, void *pData, uint nDataSize, void **pDest, int flag ZEND_FILE_LINE_DC);

ZEND_API int _zend_hash_index_update_or_next_insert(HashTable *ht, ulong h, void *pData, uint nDataSize, void **pDest, int flag ZEND_FILE_LINE_DC);

ZEND_API int zend_hash_add_empty_element(HashTable *ht, const char *arKey, uint nKeyLength);
{% endhighlight %}

3\. 数据在发生更新和写入操作的时候，是会进行阻塞处理的，为此，php提供了两个宏，来处理，具体的实现，这里不在详细描述
{% highlight c %}HANDLE_BLOCK_INTERRUPTIONS();
...
HANDLE_UNBLOCK_INTERRUPTIONS();
{% endhighlight %}

4\. HashTable中Bucket以及KEY，value等，都是在堆里面申请，其中 bucket和key的存储在一起，可以通过指针偏移拿到key值
{% highlight c %} p = (Bucket *) pemalloc(sizeof(Bucket) + nKeyLength, ht->persistent);
if (!p) {
	return FAILURE;
}
p->arKey = (const char*)(p + 1);
memcpy((char*)p->arKey, arKey, nKeyLength);
{% endhighlight %}

5\. 非常重要的rehash，hash的KEY太多，如果tablesize小，则容易退化成双向链表，性能受到很大影响

5.1\. 什么时候启动rehash 如果已有KEY的数量比nTablesize还多的时候
{% highlight c %}
#define ZEND_HASH_IF_FULL_DO_RESIZE(ht)		\
if ((ht)->nNumOfElements > (ht)->nTableSize) {	\
	zend_hash_do_resize(ht);					\
}
{% endhighlight %}

5.2\. 具体步骤是怎么样的呢
- 第一步，申请2倍 ntablesize大小的空间，存放`Bucket`指针"数组"
- 第二步，阻塞进程
- 第三步，拿到原来HashTable 顺序链表的头指针p，通过p->pListNext启动循环
	- 为 p->ListNext 申请内存
	- 找到p->ListNext 经过hash算法应该在的bucket
	- 判断bucket指向是否有冲撞，
		- 冲撞则遍历"冲撞双向链表",记在双向链表最后，同时构成双向链表
		- 没有冲撞，则记在bucket指向的地址
- 第四步，打开阻塞的进程

HashTable还有非常多的操作，都比有意思，例如像 `copy`, `merge`， `find`，`compare`， `sort` 等等，这里不在一一说明。


### 2.3 php数组和HashTable的关系
对于php的开发者来说，HashTbale的概念被弱化了，php提供了非常灵活的`array`，实际上囊括了HashTable的功能，一个php的数组，Key可以同时是 **数字 和 字符串**, php的"数组"(我们姑且叫数组)的底层实现是基于HashTable。

在考虑php数组的实现过程，我想了几个问题

1. php数组的数据结构是基于HashTable，但是HashTable的内存管理是外部控制，其实也就是，php数组的内存管理方案是怎么样的?
2. 我们知道，php是脚本语言，他有两个重要的阶段，一是，编译阶段，php的内核对php的代码文件进行词法分析和语法分析，生成opcodes，二是，执行阶段，编译成的opcodes在php的VM里面运行，**困扰我的一个问题是**，HashTable的数据区是一个无类型的指针，(`void *pData; `)，那么经过编译生成的opcodes是如何描述data类型的，以保证VM执行中，可以正常的获取存到HashTable中的数据

实际上除了这两个问题，还有很多编译上的问题，我们本次重点是了解php 5.4中数组的数据结构和基础算法，对于编译的问题，放在下一次文章中，重点研究，先简单的看一下源码，在php5.4 zend内核中，zend.c:1321。  

{% highlight c %}
EG(active_op_array) = zend_compile_file(file_handle, type TSRMLS_CC);
if (file_handle->opened_path) {
	int dummy = 1;
	zend_hash_add(&EG(included_files), file_handle->opened_path, strlen(file_handle->opened_path) + 1, (void *)&dummy, sizeof(int), NULL);
}
zend_destroy_file_handle(file_handle TSRMLS_CC);
if (EG(active_op_array)) {
	EG(return_value_ptr_ptr) = retval ? retval : NULL;
	zend_execute(EG(active_op_array) TSRMLS_CC);
	zend_exception_restore(TSRMLS_C);
	....
{% endhighlight %}

从源码当中，我们可以看到这两个阶段
- zend_compile_file()函数是启动编译, `EG`这种宏的定义方式是php比较独特的运用方式，一般G是global的缩写，globals的生命周期一般比较长，跨越整个request的请求，这里就是把编译的相关信息，放在 `executor.globals`这个变量里面
- zend_execute 是启动opcodes的执行

我们要看php的`array`是怎么实现的，现在的重点变成，实现`array的数据结构 + 算法`, 为此，我们从实现array的各种算法入手

{% highlight c %}
PHP_FUNCTION(count)
{
	zval *array;
	long mode = COUNT_NORMAL;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|l", &array, &mode) == FAILURE) {
		return;
	}
	...
}
{% endhighlight %}


## 三.php7.0的HashTable设计

在看php7.0的HashTable设计前，我们看前面5.4中bucket的一个设计，看下面一张简单的图

![php5.4 bucket设计](/images/php/bucket.jpg)

php5.4设计的bucket存放的内容，包含一个 `const char *arKey;` 通常情况下，可以申请一个key长度的内存，在将指针指向该内存。 但是从图中，我们可以看到，php5.4在设计中，考虑的是，在了解Key长度的情况下，一次性申请的内存大小是
- len(bucket) + len(arKey)

这有什么好处？ 很简单，程序在寻找key内容的时候，通过指针的偏移就可以拿到key的内容，而不是根据一个随机地址去找key的内容，在性能上能够得到大幅度的提高，基于这种思想，php7.0的HashTable设计做了很大的改进。

### 3.1. HashTable结构图

我们简单看一张php7.0的HashTable图

![php7.0 hashtable设计简图](/images/php/php7.0_hashtable.jpg)

从图中，我们可以把7.0的HashTable分成三个部分来看

- 第一部分是，我们称之为HashTable的"头节点"， 这里面包含着一个HashTable的容量大小，使用的数量，剩余数量，引用情况，等等
- 第二部分，称为"目录区"，对一个Key进行计算，得出Hash值，从目录里面，查到数据存储的index值，可以快速的寻找到hash值下面的第一个元素
- 第三部分，称为"数据存储区"，数据存储主要面临下面几个问题
	- 初始化
	- hash冲突解决方案
	- 扩容方案
	- 数据删除





php7.0的count()操作


## 四.总结比较

花了很长时间了解php5.4的HashTable设计，实际上，我们能够感受出，php5.4的HashTable设计的非常简单，很容易理解，但是对于程序来说，核心问题是**内存和效率**, 
1. 内存方面，一个bucket在64个HashTable，除去Key 和 Data的占用，在64位机器上的内存占用在
	() + (8 * 64) + (8 * 8 + len(Key))

2. 效率方面，HashTable查找一个Key，要经历多次指针寻址，性能比较差

## 五.后记